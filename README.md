Домашнее задание: система медиамониторинга

Задача: вам нужно разработать REST API (только backend!) для системы, которая поможет собирать информацию и готовить сводные отчёты о новостных публикациях в Интернете.

Пользовательские сценарии:

1) Добавление новости. В систему передаётся URL новостного материала в Интернете. Система скачивает HTML по этому URL и создаёт на его основе сущность со следующими полями:

- дата (текущая дата)
- URL (нам его передали в запросе)
- название новости (его проще всего взять из тега title)

В ответ возвращается ID сущности.

2) Получение списка новостей. Система возвращает список (массив) ранее созданных сущностей с полями:

- ID
- дата
- URL
- название новости

3) Формирование сводного отчёта. В систему передаётся массив из нескольких ID. Система формирует и сохраняет на диск простой HTML-файл со списком примерно такого вида:

```html
<ul>
  <li><a href="...">Заголовок новости 1</a><li>
  <li><a href="...">Заголовок новости 2</a><li>
</ul>
```

В ответ возвращается ссылка на этот файл.

---

Важные замечания:

1) Вам нужно самостоятельно продумать всё, что касается архитектуры этого приложения. Если будут вопросы — задавайте. Не бойтесь допускать ошибки: весь смысл домашки в том, чтобы потом их обсудить и исправить.

2) Вы можете взять за основу любой фреймворк, но обращаться к методам и классам фреймворка можно только на слое Infrastructure. Другими словами, ни на слое Domain, ни на слое Application не должно использоваться ничего, кроме написанных вами классов.

3) Для хранения сущностей вы можете использовать БД или файловую систему, это не принципиально, но — см. предыдущее замечание.

--- 
## Правки 

### Domain

Entity

- в Post можно упаковать поле $title в VO
- Post не должен быть JsonSerializable — он никогда не возвращается напрямую
- для Post не нужен сеттер для ID

Storage

- в PostStorageInterface метод findById должен возвращать nullable Post
- комментарий про ActiveRecord не очень удачный (разобрать)
- интерфейс ReportStorageInterface здесь не требуется

Clients

- HttpClientInterface относится к слою Application

### Application

UseCase

- AddNewPostUseCase не должен упаковывать новый Post в DTO (для этого нужен mapper)
- AddNewPostUseCase не должен сам парсить заголовок статьи (для этого нужен отдельный парсер)
- ListAllPostsUseCase не должен упаковывать коллекцию Post в DTO (для этого нужен mapper)
- CreatePostReportByIdsUseCase не должен сам генерировать отчёт (для этого нужен отдельный генератор)

### Infrastructure

- все каталоги, которые относятся к фреймворку, нужно вынести на уровень выше (за пределы Infrastructure)
- остальные подкаталоги лучше именовать в единственном числе (Storage вместо Storages и т.д.)

Clients

- метод getPageTitle должен возвращать DTO, а не строку

Storages

- в целом PostStorage сделан грамотно, но есть нюансы
- но в нём нужно добавить обработку ошибок (например, если метод findById ничего не найдёт)
- при сохранении нового Post тоже нужно присвоить ему новый ID через рефлексию
- для информации: в реальных ORM сущности обычно регидрируются без вызова конструктора

Controllers

- PostController лучше разделить на три контроллера по кол-ву UseCase
- при этом каждый контроллер должен внедрять свой UseCase как зависимость через конструктор
```php
class AddNewPostController extends Controller
{
    public function __construct(private readonly AddNewPostUseCase $useCase)
    {
    }

    // Код контроллера
}
```
